package com.ftrue.day12.inner.demo01;

/**
 * @ClassName InnerDemo01
 * @Description 此类用于演示功能
 * @Author Shark
 * @DateTime 2021年07月12日 08时43分
 * @Version 1.0
 *
 * 内部类:
 *      在一个类中存在另外的一个类
 *
 * 分类:
 *      成员内部类:
 *          学习目的:当一个类不想被外界所访问,只供自己使用,可以将这个类声明在一个类中,并且将这个内部类设置为private
 *          分类:
 *              实例成员内部类(了解)
 *              静态成员内部类(了解)
 *      局部内部类
 *          学习目的:简化接口中的使用步骤(匿名内部类)
 *          分类:
 *              标准局部内部类(了解)
 *              匿名局部内部类(重点)
 *
 *
 * 实例成员内部类:
 *      格式:
 *          public class 外部类类名 {
 *              修饰符 class 内部类类名 {}
 *          }
 *
 *      特点:
 *          1.内部类的权限访问级别
 *              四种都可以,推荐private
 *          2.如何创建内部类对象
 *              直接声明初始化
 *                  外部类类名.内部类类名 内部类对象名 = new 外部类类名().new 内部类类名();
 *              先声明后初始化
 *                  a.外部类类名 外部类对象名 = new 外部类类名();
 *                  b.外部类类名.内部类类名 内部类对象名 = 外部类对象名.new 内部类类名();
 *
 *              如何选择直接声明初始化或者先声明后初始化?
 *                  在程序中会不会使用到外部类对象,如果使用到,选择先声明后初始化,如果使用不到,选择直接声明初始化
 *          3.内部类和外部类之间的访问
 *              内部类访问外部类
 *                  当内部类和外部类成员变量或者成员方法不同名的时候
 *                      内部类可以访问外部类中全部成员
 *                  当内部类和外部类成员变量或者成员方法同名的时候
 *                      可以通过外部类类名.this.外部类成员名进行访问
 *              外部类访问内部类
 *                  需要在外部类的实例方法中创建内部类对象
 *              注意事项
 *                  1.在实例成员内部类中不可以声明静态成员,实例成员内部类是随着对象的创建而加载,
 *                      静态成员是随着类的加载而加载,当静态成员加载的时候,内部类可能还没有加载,
 *                         这个时候该静态成员没有存储的位置,所以编译报错
 *                  2.在外部类中访问内部类,不能再静态方法或者静态代码块中创建实例成员内部类对象
 *                  3.在外部类的实例方法中,可以通过内部类对象访问内部类中的私有成员
 */
public class InnerDemo01 {
	public static void main(String[] args) {
		//直接声明初始化
		//Outer.Inner inner = new Outer().new Inner();

		//先声明后初始化
		Outer outer = new Outer();
		Outer.Inner inner = outer.new Inner();

		inner.method();

	}
}
