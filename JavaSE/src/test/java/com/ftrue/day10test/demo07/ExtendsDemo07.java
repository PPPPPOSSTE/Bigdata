package com.ftrue.day10test.demo07;

/**
 * @ClassName: ExtendsDemo03
 * @Description:
 * @Author: zhiqi zhang on 2021/7/9 9:48
 * @Version: 1.0
 */
/**
 * 方法的重写:
 *      在子父类继承关系中(或者实现关系中),出现了方法名相同,形参列表相同,且权限修饰符和返回值类型符合相应规则的现象
 *
 * 重写的前提条件:
 *      1.必须存在子父类继承关系(或者实现关系)
 *      2.方法名必须相同
 *      3.形参列表必须相同
 *      4.权限修饰符
 *          子类重写后方法的权限修饰符必须大于等于父类方法的权限修饰符,且方法重写的注意事项除外
 *      5.返回值类型
 *          在内存中:
 *              子类重写方法的返回值类型在内存中必须和父类方法的返回值类型相同.
 *          在代码中:
 *              父类被重写方法的返回值类型是void,子类重写方法的返回值类型必须和父类方法的返回值类型相同
 *              父类被重写方法的返回值类型是基本数据类型,子类重写方法的返回值类型必须和父类方法的返回值类型相同
 *              父类被重写方法的返回值类型是引用数据类型,子类重写方法的返回值类型必须和父类方法的返回值类型相同
 *                  或者是父类方法返回值类型的子类类型(其实是面向对象的第三大特征:多态)
 *
 * 重写的注意事项:
 *      1.有些时候,子类的方法没有满足重写的前提条件,代码也没有编译报错,有可能导致开发中的逻辑错误,
 *          正是因为如此Java提供了一种注解语法
 *              注解:针对程序中的包,类,接口,方法,变量等,进行语法限制的规则
 *          方法重写注解:
 *              用来检测子类(或者实现类)的方法是否满足重写条件,如果不满足重写的语法条件,代码会直接报错
 *          格式:
 *              @Override
 *              修饰符 返回值类型 方法名 () {}
 *      2.父类中的私有方法不能重写
 *      3.不同包下父类的缺省方法不能重写
 */
public class ExtendsDemo07 {
    public static void main(String[] args) {
        //创建子类对象
        SubClass sc = new SubClass();
        sc.method();
    }
}
